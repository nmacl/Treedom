// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol";

contract Freezer is IERC721Receiver, Ownable, KeeperCompatibleInterface {
    
    public uint256 totalTokens = 0;
    
    mapping(address => uint256[]) owners;
    
    mapping(uint256 => uint256) timeStamps;
    
    private uint256[] toThaw;
    
    private ERC721 nftContract;
    
    /**
    * Public counter variable
    */
    uint public counter;

    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;
    
    constructor(uint updateInterval) {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;

      counter = 0;
    }

    function checkUpkeep(bytes calldata checkData) external override returns (bool upkeepNeeded, bytes memory performData) {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata performData) external override {
        lastTimeStamp = block.timestamp;
        counter = counter + 1;
        uint256 index;
        
        for(index = 0; index < toThaw.length; index++) {
            uint256 token = toThaw[index];
            if(timeStamps[token] < counter - 30) {
                toThaw[index] = toThaw[toThaw.length - 1];
                toThaw.pop();
                timeStamps[token] = 0;
                owners[msg.sender][index] = owners[msg.sender][owners[msg.sender].length - 1];
                owners[msg.sender].pop();
                
                nftContract.safeTransferFrom(address(this), msg.sender, token);
                
                totalTokens = totalTokens - 1;
            }
        }
        
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    
    }   

    function setNFTContract(ERC721 addy) external onlyOwner {
        nftContract = addy;
    }

    function getNFTContract() external view returns(ERC721){
        return nftContract;
    }

    function thaw(uint256 tokenId) external returns(bool) {
        require(owners[msg.sender].length != 0, "No tokens detected");
        uint256[] memory tokens = owners[msg.sender];
        uint256 index;
        
        for(index = 0; index < tokens.length; index++)  {
            if(tokens[index] == tokenId) {
                uint256 token = tokens[index];
                timeStamps[token] = counter;
                toThaw.push(token);
                return true;
            }
        }
        
        return false;
    }
    
    function getTotalTokens() view external returns(uint256) {
        return totalTokens;
    }

    function getTokensOfOwner(address addy) external view returns(uint256[] memory) {
        require(owners[addy].length != 0, "No tokens detected");
        return owners[addy];
    }
    
    function getStamp(uint256 stamp) view external returns(uint256) {
        return timeStamps[stamp];
    }

    function onERC721Received(
        address,
        address from,
        uint256 tokenId,
        bytes calldata
    )
        override
        external
        returns(bytes4)
    {
        require(address(msg.sender) == address(nftContract), "Not treedom contract");
        owners[from].push(tokenId);
        totalTokens = totalTokens + 1; 
        return 0x150b7a02;
    }
    
    
}